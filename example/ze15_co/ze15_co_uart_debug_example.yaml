esphome:
  name: co-monitor-simple
  friendly_name: CO Monitor Simple
  platform: ESP32
  board: esp32dev

# Example 1: Initiative/Passive Mode using UART debug
sensor:
  - platform: template
    name: "CO Concentration"
    id: co_sensor
    unit_of_measurement: 'ppm'
    accuracy_decimals: 1
    device_class: carbon_monoxide
    state_class: measurement
    icon: "mdi:molecule-co"
    lambda: "return {};"

binary_sensor:
  - platform: template
    name: "CO Sensor Fault"
    id: sensor_fault
    device_class: problem
    lambda: "return false;"

uart:
  - id: uart_ze15
    rx_pin: GPIO16
    tx_pin: GPIO17  # Optional for passive mode
    baud_rate: 9600
    debug:
      direction: RX
      dummy_receiver: true
      sequence:
        - lambda: |-
            UARTDebug::log_hex(direction, bytes, ':');  // Log hex data
            
            // Check for valid Initiative mode packet
            if (bytes.size() == 9 && bytes[0] == 0xFF && bytes[1] == 0x04) {
              // Validate checksum
              uint8_t sum = 0;
              for (int i = 1; i < 8; i++) {
                sum += bytes[i];
              }
              uint8_t checksum = (~sum) + 1;
              
              if (checksum == bytes[8]) {
                // Extract sensor fault (bit 7 of high byte)
                bool fault = (bytes[4] & 0x80) != 0;
                id(sensor_fault).publish_state(fault);
                
                // Calculate CO concentration
                // CO = ((low 5 bits of high byte) * 256 + low byte) * 0.1
                uint16_t raw = ((bytes[4] & 0x1F) << 8) | bytes[5];
                float co_ppm = raw * 0.1;
                
                id(co_sensor).publish_state(co_ppm);
                
                ESP_LOGI("ze15", "CO: %.1f ppm, Fault: %s", 
                         co_ppm, fault ? "YES" : "NO");
              }
            }

# Example 2: Q&A Mode with commands
esphome:
  name: co-monitor-qa
  on_boot:
    # Send initial Q&A command to switch mode
    - uart.write:
        id: uart_ze15
        data: [0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79]

interval:
  - interval: 60s
    then:
      # Send read command
      - uart.write:
          id: uart_ze15
          data: [0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79]

sensor:
  - platform: template
    name: "CO Concentration Q&A"
    id: co_sensor_qa
    unit_of_measurement: 'ppm'
    accuracy_decimals: 1
    device_class: carbon_monoxide
    lambda: "return {};"

uart:
  - id: uart_ze15
    rx_pin: GPIO16
    tx_pin: GPIO17  # Required for Q&A mode
    baud_rate: 9600
    debug:
      direction: RX
      dummy_receiver: true
      sequence:
        - lambda: |-
            // Check for Q&A response
            if (bytes.size() == 9 && bytes[0] == 0xFF && bytes[1] == 0x86) {
              // Validate checksum
              uint8_t sum = 0;
              for (int i = 1; i < 8; i++) {
                sum += bytes[i];
              }
              uint8_t checksum = (~sum) + 1;
              
              if (checksum == bytes[8]) {
                // Extract CO from bytes 2 and 3 in Q&A response
                bool fault = (bytes[2] & 0x80) != 0;
                uint16_t raw = ((bytes[2] & 0x1F) << 8) | bytes[3];
                float co_ppm = raw * 0.1;
                
                id(co_sensor_qa).publish_state(co_ppm);
                ESP_LOGI("ze15", "Q&A - CO: %.1f ppm", co_ppm);
              }
            }
